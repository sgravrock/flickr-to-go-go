// Code generated by counterfeiter. DO NOT EDIT.
package dlfakes

import (
	"net/http"
	"sync"

	"github.com/sgravrock/flickr-to-go-go/dl"
	"github.com/sgravrock/flickr-to-go-go/flickrapi"
	"github.com/sgravrock/flickr-to-go-go/storage"
)

type FakeDownloader struct {
	GetRecentPhotoIdsStub        func(timestamp uint32, flickr flickrapi.Client) ([]string, error)
	getRecentPhotoIdsMutex       sync.RWMutex
	getRecentPhotoIdsArgsForCall []struct {
		timestamp uint32
		flickr    flickrapi.Client
	}
	getRecentPhotoIdsReturns struct {
		result1 []string
		result2 error
	}
	getRecentPhotoIdsReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	DownloadPhotolistStub        func(flickr flickrapi.Client, fs storage.Storage) ([]flickrapi.PhotoListEntry, error)
	downloadPhotolistMutex       sync.RWMutex
	downloadPhotolistArgsForCall []struct {
		flickr flickrapi.Client
		fs     storage.Storage
	}
	downloadPhotolistReturns struct {
		result1 []flickrapi.PhotoListEntry
		result2 error
	}
	downloadPhotolistReturnsOnCall map[int]struct {
		result1 []flickrapi.PhotoListEntry
		result2 error
	}
	DownloadPhotoInfoStub        func(flickr flickrapi.Client, fs storage.Storage, id string) error
	downloadPhotoInfoMutex       sync.RWMutex
	downloadPhotoInfoArgsForCall []struct {
		flickr flickrapi.Client
		fs     storage.Storage
		id     string
	}
	downloadPhotoInfoReturns struct {
		result1 error
	}
	downloadPhotoInfoReturnsOnCall map[int]struct {
		result1 error
	}
	DownloadOriginalStub        func(httpClient *http.Client, fs storage.Storage, photo flickrapi.PhotoListEntry) error
	downloadOriginalMutex       sync.RWMutex
	downloadOriginalArgsForCall []struct {
		httpClient *http.Client
		fs         storage.Storage
		photo      flickrapi.PhotoListEntry
	}
	downloadOriginalReturns struct {
		result1 error
	}
	downloadOriginalReturnsOnCall map[int]struct {
		result1 error
	}
	OriginalExistsStub        func(fs storage.Storage, photoId string) bool
	originalExistsMutex       sync.RWMutex
	originalExistsArgsForCall []struct {
		fs      storage.Storage
		photoId string
	}
	originalExistsReturns struct {
		result1 bool
	}
	originalExistsReturnsOnCall map[int]struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDownloader) GetRecentPhotoIds(timestamp uint32, flickr flickrapi.Client) ([]string, error) {
	fake.getRecentPhotoIdsMutex.Lock()
	ret, specificReturn := fake.getRecentPhotoIdsReturnsOnCall[len(fake.getRecentPhotoIdsArgsForCall)]
	fake.getRecentPhotoIdsArgsForCall = append(fake.getRecentPhotoIdsArgsForCall, struct {
		timestamp uint32
		flickr    flickrapi.Client
	}{timestamp, flickr})
	fake.recordInvocation("GetRecentPhotoIds", []interface{}{timestamp, flickr})
	fake.getRecentPhotoIdsMutex.Unlock()
	if fake.GetRecentPhotoIdsStub != nil {
		return fake.GetRecentPhotoIdsStub(timestamp, flickr)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getRecentPhotoIdsReturns.result1, fake.getRecentPhotoIdsReturns.result2
}

func (fake *FakeDownloader) GetRecentPhotoIdsCallCount() int {
	fake.getRecentPhotoIdsMutex.RLock()
	defer fake.getRecentPhotoIdsMutex.RUnlock()
	return len(fake.getRecentPhotoIdsArgsForCall)
}

func (fake *FakeDownloader) GetRecentPhotoIdsArgsForCall(i int) (uint32, flickrapi.Client) {
	fake.getRecentPhotoIdsMutex.RLock()
	defer fake.getRecentPhotoIdsMutex.RUnlock()
	return fake.getRecentPhotoIdsArgsForCall[i].timestamp, fake.getRecentPhotoIdsArgsForCall[i].flickr
}

func (fake *FakeDownloader) GetRecentPhotoIdsReturns(result1 []string, result2 error) {
	fake.GetRecentPhotoIdsStub = nil
	fake.getRecentPhotoIdsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeDownloader) GetRecentPhotoIdsReturnsOnCall(i int, result1 []string, result2 error) {
	fake.GetRecentPhotoIdsStub = nil
	if fake.getRecentPhotoIdsReturnsOnCall == nil {
		fake.getRecentPhotoIdsReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.getRecentPhotoIdsReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeDownloader) DownloadPhotolist(flickr flickrapi.Client, fs storage.Storage) ([]flickrapi.PhotoListEntry, error) {
	fake.downloadPhotolistMutex.Lock()
	ret, specificReturn := fake.downloadPhotolistReturnsOnCall[len(fake.downloadPhotolistArgsForCall)]
	fake.downloadPhotolistArgsForCall = append(fake.downloadPhotolistArgsForCall, struct {
		flickr flickrapi.Client
		fs     storage.Storage
	}{flickr, fs})
	fake.recordInvocation("DownloadPhotolist", []interface{}{flickr, fs})
	fake.downloadPhotolistMutex.Unlock()
	if fake.DownloadPhotolistStub != nil {
		return fake.DownloadPhotolistStub(flickr, fs)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.downloadPhotolistReturns.result1, fake.downloadPhotolistReturns.result2
}

func (fake *FakeDownloader) DownloadPhotolistCallCount() int {
	fake.downloadPhotolistMutex.RLock()
	defer fake.downloadPhotolistMutex.RUnlock()
	return len(fake.downloadPhotolistArgsForCall)
}

func (fake *FakeDownloader) DownloadPhotolistArgsForCall(i int) (flickrapi.Client, storage.Storage) {
	fake.downloadPhotolistMutex.RLock()
	defer fake.downloadPhotolistMutex.RUnlock()
	return fake.downloadPhotolistArgsForCall[i].flickr, fake.downloadPhotolistArgsForCall[i].fs
}

func (fake *FakeDownloader) DownloadPhotolistReturns(result1 []flickrapi.PhotoListEntry, result2 error) {
	fake.DownloadPhotolistStub = nil
	fake.downloadPhotolistReturns = struct {
		result1 []flickrapi.PhotoListEntry
		result2 error
	}{result1, result2}
}

func (fake *FakeDownloader) DownloadPhotolistReturnsOnCall(i int, result1 []flickrapi.PhotoListEntry, result2 error) {
	fake.DownloadPhotolistStub = nil
	if fake.downloadPhotolistReturnsOnCall == nil {
		fake.downloadPhotolistReturnsOnCall = make(map[int]struct {
			result1 []flickrapi.PhotoListEntry
			result2 error
		})
	}
	fake.downloadPhotolistReturnsOnCall[i] = struct {
		result1 []flickrapi.PhotoListEntry
		result2 error
	}{result1, result2}
}

func (fake *FakeDownloader) DownloadPhotoInfo(flickr flickrapi.Client, fs storage.Storage, id string) error {
	fake.downloadPhotoInfoMutex.Lock()
	ret, specificReturn := fake.downloadPhotoInfoReturnsOnCall[len(fake.downloadPhotoInfoArgsForCall)]
	fake.downloadPhotoInfoArgsForCall = append(fake.downloadPhotoInfoArgsForCall, struct {
		flickr flickrapi.Client
		fs     storage.Storage
		id     string
	}{flickr, fs, id})
	fake.recordInvocation("DownloadPhotoInfo", []interface{}{flickr, fs, id})
	fake.downloadPhotoInfoMutex.Unlock()
	if fake.DownloadPhotoInfoStub != nil {
		return fake.DownloadPhotoInfoStub(flickr, fs, id)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.downloadPhotoInfoReturns.result1
}

func (fake *FakeDownloader) DownloadPhotoInfoCallCount() int {
	fake.downloadPhotoInfoMutex.RLock()
	defer fake.downloadPhotoInfoMutex.RUnlock()
	return len(fake.downloadPhotoInfoArgsForCall)
}

func (fake *FakeDownloader) DownloadPhotoInfoArgsForCall(i int) (flickrapi.Client, storage.Storage, string) {
	fake.downloadPhotoInfoMutex.RLock()
	defer fake.downloadPhotoInfoMutex.RUnlock()
	return fake.downloadPhotoInfoArgsForCall[i].flickr, fake.downloadPhotoInfoArgsForCall[i].fs, fake.downloadPhotoInfoArgsForCall[i].id
}

func (fake *FakeDownloader) DownloadPhotoInfoReturns(result1 error) {
	fake.DownloadPhotoInfoStub = nil
	fake.downloadPhotoInfoReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDownloader) DownloadPhotoInfoReturnsOnCall(i int, result1 error) {
	fake.DownloadPhotoInfoStub = nil
	if fake.downloadPhotoInfoReturnsOnCall == nil {
		fake.downloadPhotoInfoReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.downloadPhotoInfoReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDownloader) DownloadOriginal(httpClient *http.Client, fs storage.Storage, photo flickrapi.PhotoListEntry) error {
	fake.downloadOriginalMutex.Lock()
	ret, specificReturn := fake.downloadOriginalReturnsOnCall[len(fake.downloadOriginalArgsForCall)]
	fake.downloadOriginalArgsForCall = append(fake.downloadOriginalArgsForCall, struct {
		httpClient *http.Client
		fs         storage.Storage
		photo      flickrapi.PhotoListEntry
	}{httpClient, fs, photo})
	fake.recordInvocation("DownloadOriginal", []interface{}{httpClient, fs, photo})
	fake.downloadOriginalMutex.Unlock()
	if fake.DownloadOriginalStub != nil {
		return fake.DownloadOriginalStub(httpClient, fs, photo)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.downloadOriginalReturns.result1
}

func (fake *FakeDownloader) DownloadOriginalCallCount() int {
	fake.downloadOriginalMutex.RLock()
	defer fake.downloadOriginalMutex.RUnlock()
	return len(fake.downloadOriginalArgsForCall)
}

func (fake *FakeDownloader) DownloadOriginalArgsForCall(i int) (*http.Client, storage.Storage, flickrapi.PhotoListEntry) {
	fake.downloadOriginalMutex.RLock()
	defer fake.downloadOriginalMutex.RUnlock()
	return fake.downloadOriginalArgsForCall[i].httpClient, fake.downloadOriginalArgsForCall[i].fs, fake.downloadOriginalArgsForCall[i].photo
}

func (fake *FakeDownloader) DownloadOriginalReturns(result1 error) {
	fake.DownloadOriginalStub = nil
	fake.downloadOriginalReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDownloader) DownloadOriginalReturnsOnCall(i int, result1 error) {
	fake.DownloadOriginalStub = nil
	if fake.downloadOriginalReturnsOnCall == nil {
		fake.downloadOriginalReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.downloadOriginalReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDownloader) OriginalExists(fs storage.Storage, photoId string) bool {
	fake.originalExistsMutex.Lock()
	ret, specificReturn := fake.originalExistsReturnsOnCall[len(fake.originalExistsArgsForCall)]
	fake.originalExistsArgsForCall = append(fake.originalExistsArgsForCall, struct {
		fs      storage.Storage
		photoId string
	}{fs, photoId})
	fake.recordInvocation("OriginalExists", []interface{}{fs, photoId})
	fake.originalExistsMutex.Unlock()
	if fake.OriginalExistsStub != nil {
		return fake.OriginalExistsStub(fs, photoId)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.originalExistsReturns.result1
}

func (fake *FakeDownloader) OriginalExistsCallCount() int {
	fake.originalExistsMutex.RLock()
	defer fake.originalExistsMutex.RUnlock()
	return len(fake.originalExistsArgsForCall)
}

func (fake *FakeDownloader) OriginalExistsArgsForCall(i int) (storage.Storage, string) {
	fake.originalExistsMutex.RLock()
	defer fake.originalExistsMutex.RUnlock()
	return fake.originalExistsArgsForCall[i].fs, fake.originalExistsArgsForCall[i].photoId
}

func (fake *FakeDownloader) OriginalExistsReturns(result1 bool) {
	fake.OriginalExistsStub = nil
	fake.originalExistsReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDownloader) OriginalExistsReturnsOnCall(i int, result1 bool) {
	fake.OriginalExistsStub = nil
	if fake.originalExistsReturnsOnCall == nil {
		fake.originalExistsReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.originalExistsReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeDownloader) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getRecentPhotoIdsMutex.RLock()
	defer fake.getRecentPhotoIdsMutex.RUnlock()
	fake.downloadPhotolistMutex.RLock()
	defer fake.downloadPhotolistMutex.RUnlock()
	fake.downloadPhotoInfoMutex.RLock()
	defer fake.downloadPhotoInfoMutex.RUnlock()
	fake.downloadOriginalMutex.RLock()
	defer fake.downloadOriginalMutex.RUnlock()
	fake.originalExistsMutex.RLock()
	defer fake.originalExistsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDownloader) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ dl.Downloader = new(FakeDownloader)
